"Prev abandoned VIMRC settings
"========================================================================
" function! s:check_back_space()
"   let col = col('.') - 1
"   return !col || getline('.')[col - 1]  =~ '\s'
" endfunction

" let g:ulti_expand_res = 0 "default value, just set once
" function! Tab_Snippet_Complete()
"   let snippet = UltiSnips#ExpandSnippet()
"   if g:ulti_expand_res > 0
"     return snippet
"   endif
"   if <SID>check_back_space()
"     return "\<TAB>"
"   endif
"   let manualcomplete = neocomplete#start_manual_complete()
"   return manualcomplete
" endfunction
" inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<C-R>=Tab_Snippet_Complete()\<CR>"
"-----------------------------------------------------------
"     NEOMAKE
"-----------------------------------------------------------
" augroup Neomake
"   au!
"   autocmd BufWritePost * Neomake
  " autocmd! BufWritePost,BufReadPost * Neomake
" augroup END
" let g:neomake_verbose = 0
" let g:neomake_list_height = 6
" let g:neomake_open_list = 2
" let g:quickfixsigns_protect_sign_rx = '^neomake_'
" let g:neomake_warning_sign = {
"   \ 'text': 'W',
"   \ 'texthl': 'WarningMsg',
"   \ }
" let g:neomake_error_sign = {
"   \ 'text': 'E',
"   \ 'texthl': 'ErrorMsg',
"   \ }
" let g:neomake_html_enabled_makers = ['']
" let g:neomake_cpp_enabled_makers = ['clang']
" let g:neomake_cpp_clang_maker = {
"       \ 'args': ['-std=c++14', '-Wall', '-Wextra', '-Weverything', '-pedantic']
"       \ }

"Moves to the previous set of parentheses and operate on its contents
onoremap lp :<c-u>normal! F)vi(<cr>
"Moves to the next set of parentheses and operate on its contents
onoremap pa :<c-u>normal! f(vi(<cr>
"Moves to the previous set of braces and operate on its contents
onoremap lc :<c-u>normal! F}vi{<cr>
"Moves to the next set of braces and operate on its contents
onoremap cb :<c-u>normal! f{vi{<cr>
" These two mappings reduce a sequence of empty (;b) or blank (;n) lines into a
" single line
nnoremap ;b   GoZ<Esc>:g/^$/.,/./-j<CR>Gdd
nnoremap ;n   GoZ<Esc>:g/^[ <Tab>]*$/.,/[^ <Tab>]/-j<CR>Gdd
" make last typed word uppercase
inoremap :u <esc>viwUea

vnoremap ∆ xp`[V`]
vnoremap ˚ xkP`[V`]
nnoremap ∆ ddp
nnoremap ˚ ddkP
"For each char here it applies a remap deleting all occurrences of the car with
"an a operator or the things past it with an i operator
" for char in [ '_', '.', ':', ',', ';', '<bar>', '/', '<bslash>', '*', '+', '%', '`' ]
"   execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
"   execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
"   execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
"   execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
" endfor
" "------------------------------------
" " Neosnippet
" "------------------------------------
" let g:neosnippet#enable_conceal_markers = 1


" imap <C-U> <Plug>(neosnippet_expand_or_jump)
" smap <C-U> <Plug>(neosnippet_expand_or_jump)
" xmap <C-U> <Plug>(neosnippet_expand_target)

" " SuperTab like snippets behavior.
" " Note: It must be "imap" and "smap".  It uses <Plug> mappings.
" imap <c-u> <Plug>(neosnippet_expand_or_jump)
" " imap <expr><TAB>
" " \ pumvisible() ? "\<C-n>" :
" " \ neosnippet#expandable_or_jumpable() ?
" " \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
"       \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" " For conceal markers.
" if has('conceal')
"   set conceallevel=2 concealcursor=niv
" endif
" "let g:neocomplete#force_omni_input_patterns.javascript = '[^. \t]\.\w*'
" " Enable snipMate compatibility feature.
" let g:neosnippet#enable_snipmate_compatibility = 1

" " Tell Neosnippet about the other snippets
" " let g:neosnippet#snippets_directory='~/.vim/plugged/vim-snippets/snippets'

"===================================================================
"     YouCompleteMe
"===================================================================
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe. - need to rethink this mapping
" let g:UltiSnipsExpandTrigger="<tab>"
" let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

"function! g:UltiSnips_Complete()
"  call UltiSnips#ExpandSnippet()
"  if g:ulti_expand_res == 0
"    if pumvisible()
"      return "\<C-n>"
"    else
"      call UltiSnips#JumpForwards()
"      if g:ulti_jump_forwards_res == 0
"        return "\<TAB>"
"      endif
"    endif
"  endif
"  return ""
"endfunction
"
"au BufEnter * exec \"inoremap <silent> \" . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr>"
"let g:UltiSnipsJumpForwardTrigger="<tab>"
"let g:UltiSnipsListSnippets="<c-e>"
" this mapping Enter key to <C-y> to chose the current highlight item
" and close the selection list, same as other IDEs.
" CONFLICT with some plugins like tpope/Endwise
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
let g:UltiSnipsEditSplit="vertical"

"YouCompleteMe configurations
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']

let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_always_populate_location_list = 1
"------------------------------------
" Neocomplete
"------------------------------------
" Use neocomplete.
" let g:neocomplete#enable_at_startup = 1
" Disable AutoComplPop.
" let g:acp_enableAtStartup = 0
" Use smartcase.
" let g:neocomplete#enable_smart_case = 1
" let g:neocomplete#auto_complete_delay = 1
" Set minimum syntax keyword length.
" let g:neocomplete#sources#syntax#min_keyword_length = 3
" let g:neopairs#enable = 1
" let g:neocomplete#enable_auto_select = 0
" let g:neocomplete#enable_auto_delimiter = 1
" let g:neocomplete#skip_auto_completion_time = "0.2" 
" let g:neocomplete#enable_refresh_always = 1
" Search from neocomplete, omni candidates, vim keywords.
" let g:neocomplete#fallback_mappings =
      " \ ["\<C-x>\<C-o>", "\<C-x>\<C-n>"]
" Enable heavy omni completion.
" if !exists('g:neocomplete#sources#omni#input_patterns')
"   let g:neocomplete#sources#omni#input_patterns = {}
" endif
" Define dictionary.
" let g:neocomplete#sources#dictionary#dictionaries = {
    " \ 'default' : '',
    " \ 'vimshell' : $HOME.'/.vimshell_hist',
    " \ 'scheme' : $HOME.'/.gosh_completions'
        " \ }
" Recommended key-mappings.
" inoremap <expr><C-D> neocomplete#undo_completion()
  
" <CR>: close popup and save indent.
" inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
  "return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  " return pumvisible() ? "\<C-y>" : "\<CR>"
" endfunction
" <TAB>: completion.
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-c> neocomplete#smart_close_popup()."\<C-h>"
" inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"
"- there are native text motions with do this - "b i.e cib - change inner block
"Deletes around next pair of parens - still can't crack it
" onoremap op :<c-u>normal! F(vT)<cr>
"Works similarly to the bindings above - finds quotes and operates inside them
" onoremap sq :<c-u>normal! f'vi'<cr>
" onoremap dq :<c-u>normal! f"vi"<cr>


"This sets the search highlighting which actually changes the appearance of
"neomake/ any linters warnings
" hi Search term=bold cterm=bold ctermfg=9 ctermbg=0 gui=bold guifg=#cb4b16 guibg=#073642

" Broken down into easily includeable segments
" set statusline=%f
" set statusline+=%{fugitive#statusline()} " Git Hotness
" set statusline+=%{ObsessionStatus()} "Tpope's sessions management
" set statusline+=\ %#ErrorMsg#%{neomake#statusline#QflistStatus('qf:\ ')}
" set statusline+=%#warningmsg#

"Display extra whitespace
" set list listchars=tab:»·,trail:·,nbsp:·,trail:·,nbsp:·


"Using current terminal font - which is a patched nerd font
" set guifont=Inconsolata\ for\ Powerline\ Plus\ Nerd\ File\ Types:14
" augroup MatchParens
"   au!
"   autocmd VimEnter * :DoMatchParen<CR>
" augroup END
"================================================================================
"Whitespace
"================================================================================
" function! StripWhiteSpace ()
"  exec ':%/ \+$//gc'
" endfunction
" map <leader>r :call StripWhiteSpace ()<CR>


"Courtesy of vim casts - http://vimcasts.org/episodes/show-invisibles/
" set list
" set listchars=
"This sets list tab chars to invisible
" set listchars=tab:\ \
" set listchars+=tab:▸\
" set listchars+=tab:\┆\
" set listchars+=trail:·
" set listchars+=nbsp:⣿
" set listchars+=extends:»              " show cut off when nowrap
" set listchars+=precedes:«
" "Invisible character colors
" highlight NonText guifg=#4a4a59
" highlight SpecialKey guifg=#4a4a59
"
" set omnifunc=syntaxcomplete#Complete

"=============================================================
"               Lightline
"=============================================================
" \ 'right': [ [ 'close' ], ],
" use lightline-buffer in lightline
"let g:lightline = {
"  \ 'colorscheme': 'sialoquent',
"  \ 'tabline': {
"      \ 'left': [ [ 'bufferinfo' ], [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
"      \ },
"  \ 'component_expand': {
"      \ 'buffercurrent': 'lightline#buffer#buffercurrent2',
"      \ },
"  \ 'component_type': {
"      \ 'buffercurrent': 'tabsel',
"      \ },
"  \ 'component_function': {
"      \ 'bufferbefore': 'lightline#buffer#bufferbefore',
"      \ 'bufferafter': 'lightline#buffer#bufferafter',
"      \ 'bufferinfo': 'lightline#buffer#bufferinfo',
"      \ },
"\ 'active': {
"  \   'left': [ [ 'mode', 'paste' ],
"  \             [ 'fugitive', 'readonly', 'filename', 'modified' ] ]
"  \ },
"  \ 'component': {
"  \   'readonly': '%{&filetype=="help"?"":&readonly?"":""}',
"  \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
"  \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
"  \ },
"  \ 'component_visible_condition': {
"  \   'readonly': '(&filetype!="help"&& &readonly)',
"  \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
"  \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
"  \ },
"  \ 'separator': { 'left': '', 'right': '' },
"  \ 'subseparator': { 'left': '∿', 'right': '❂' }
"  \ }
"
"
"function! LightlineModified()
"  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
"endfunction
"
"function! LightlineReadonly()
"  return &ft !~? 'help' && &readonly ? 'RO' : ''
"endfunction
"
"function! LightlineFilename()
"  let fname = expand('%:t')
"  return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
"        \ fname == '__Tagbar__' ? g:lightline.fname :
"        \ fname =~ '__Gundo\|NERD_tree' ? '' :
"        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
"        \ &ft == 'unite' ? unite#get_status_string() :
"        \ &ft == 'vimshell' ? vimshell#get_status_string() :
"        \ ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
"        \ ('' != fname ? fname : '[No Name]') .
"        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
"endfunction
"
"function! LightlineFugitive()
"  try
"    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
"      let mark = ''  " edit here for cool mark
"      let branch = fugitive#head()
"      return branch !=# '' ? mark.branch : ''
"    endif
"  catch
"  endtry
"  return ''
"endfunction
"
"function! LightlineFileformat()
"  return winwidth(0) > 70 ? &fileformat : ''
"endfunction
"
"function! LightlineFiletype()
"  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
"endfunction
"
"function! LightlineFileencoding()
"  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
"endfunction
"
"function! LightlineMode()
"  let fname = expand('%:t')
"  return fname == '__Tagbar__' ? 'Tagbar' :
"        \ fname == 'ControlP' ? 'CtrlP' :
"        \ fname == '__Gundo__' ? 'Gundo' :
"        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
"        \ fname =~ 'NERD_tree' ? 'NERDTree' :
"        \ &ft == 'unite' ? 'Unite' :
"        \ &ft == 'vimfiler' ? 'VimFiler' :
"        \ &ft == 'vimshell' ? 'VimShell' :
"        \ winwidth(0) > 60 ? lightline#mode() : ''
"endfunction
"
"function! CtrlPStatusFunc_2(str)
"  return lightline#statusline(0)
"endfunction
"
"let g:tagbar_status_func = 'TagbarStatusFunc'
"
"function! TagbarStatusFunc(current, sort, fname, ...) abort
"    let g:lightline.fname = a:fname
"  return lightline#statusline(0)
"endfunction


" lightline-buffer ui settings
" replace these symbols with ascii characters if your environment does not support unicode
"
"let g:lightline_buffer_logo = ' '
"let g:lightline_buffer_readonly_icon = ''
"" let g:lightline_buffer_modified_icon = '✭'
"let g:lightline_buffer_modified_icon = '+'
"let g:lightline_buffer_git_icon = ' '
"let g:lightline_buffer_ellipsis_icon = '..'
"let g:lightline_buffer_expand_left_icon = '◀ '
"let g:lightline_buffer_expand_right_icon = ' ▶'
"let g:lightline_buffer_active_buffer_left_icon = ''
"let g:lightline_buffer_active_buffer_right_icon = ''
"let g:lightline_buffer_separator_icon = ' '
"
"" lightline-buffer function settings
"let g:lightline_buffer_show_bufnr = 1
"let g:lightline_buffer_rotate = 0
"let g:lightline_buffer_fname_mod = ':t'
"let g:lightline_buffer_excludes = ['vimfiler']
"
"let g:lightline_buffer_maxflen = 30
"let g:lightline_buffer_maxfextlen = 3
"let g:lightline_buffer_minflen = 16
"let g:lightline_buffer_minfextlen = 3
"let g:lightline_buffer_reservelen = 20
